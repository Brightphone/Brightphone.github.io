<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://triplecc.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":true},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="函数func funcName(outerName innerName:Type,… ) outerName：是外部参数名，如果省略不写即表示外部参数名与内部参数名一致，如果为“”表示无外部参数名。““:可以使函数被调用时省去外部名， 变长参数变长参数是可以接受零个或更多输入值作为实参，函数只能有一个变长参数，而且一般应该是参数列表中的最后一个。参数值在函数内部以数组的形式可用. 默认参数值123">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift备忘">
<meta property="og:url" content="https://triplecc.github.io/2020/04/24/swift/index.html">
<meta property="og:site_name" content="Light&#39;s Blog">
<meta property="og:description" content="函数func funcName(outerName innerName:Type,… ) outerName：是外部参数名，如果省略不写即表示外部参数名与内部参数名一致，如果为“”表示无外部参数名。““:可以使函数被调用时省去外部名， 变长参数变长参数是可以接受零个或更多输入值作为实参，函数只能有一个变长参数，而且一般应该是参数列表中的最后一个。参数值在函数内部以数组的形式可用. 默认参数值123">
<meta property="og:image" content="https://triplecc.github.io/res/images/article/swift/1.png">
<meta property="article:published_time" content="2020-04-24T12:00:00.000Z">
<meta property="article:modified_time" content="2020-04-27T10:58:28.072Z">
<meta property="article:author" content="Light">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://triplecc.github.io/res/images/article/swift/1.png">

<link rel="canonical" href="https://triplecc.github.io/2020/04/24/swift/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>Swift备忘 | Light's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Light's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input" id="search-input"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

  
</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://triplecc.github.io/2020/04/24/swift/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar/lightning.png">
      <meta itemprop="name" content="Light">
      <meta itemprop="description" content="Keep going……">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Light's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Swift备忘
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-24 12:00:00" itemprop="dateCreated datePublished" datetime="2020-04-24T12:00:00+00:00">2020-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-04-27 10:58:28" itemprop="dateModified" datetime="2020-04-27T10:58:28+00:00">2020-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>func funcName(outerName innerName:Type,… )</p>
<p>outerName：是外部参数名，如果省略不写即表示外部参数名与内部参数名一致，如果为“<em>”表示无外部参数名。<br>“</em>“:可以使函数被调用时省去外部名，</p>
<h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2><p>变长参数是可以接受零个或更多输入值作为实参，函数只能有一个变长参数，而且一般应该是参数列表中的最后一个。<br>参数值在函数内部以数组的形式可用.</p>
<h2 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func test(par1:Double,par2:Double &#x3D; 4.0)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="in-out-参数"><a href="#in-out-参数" class="headerlink" title="in-out 参数"></a>in-out 参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func test(_ code:Int,error:inout String) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">var error &#x3D; &quot;error&quot;</span><br><span class="line">test(400,&amp;error)</span><br></pre></td></tr></table></figure>
<p>in-out 参数能让函数修改函数体外的变量，实际上就相当于指针。<br>in-out 参数不能有默认值，也不可以是变长参数。<br>调用时要使用取地址符号”&amp;”</p>
<a id="more"></a>
<p>函数的形参不可以再赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func printName(to names:String...) &#123;</span><br><span class="line">    for name in names &#123;</span><br><span class="line">        print(&quot;Hello \(name),Welcome ~~&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printName(names:[&quot;heliang&quot;,&quot;Feng&quot;])</span><br></pre></td></tr></table></figure>
<p>一个函数本质上是一个对象的实例，因此是可以作为返回值返回；<br>函数类型：<br>函数类型是由函数参数和返回值组成，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sortedEvenOddNumbers(_ numbers: [Int]) -&gt; (evens: [Int], odds: [Int]) &#123; </span><br><span class="line">    var evens &#x3D; [Int]()</span><br><span class="line">    var odds &#x3D; [Int]()</span><br><span class="line">    for number in numbers &#123;</span><br><span class="line">        if number%2&#x3D;&#x3D;0 &#123; </span><br><span class="line">            evens.append(number)</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            odds.append(number)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    return (evens, odds) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数类型可以表示为：<br>([Int])-([Int],[Int])<br>函数的参数在左边的圆括号中列出，返回值跟着-&gt;后面,可以解读为：<br>“一个接受整数数组作为参数并返回带有两个整数数组的元组的函数.”<br>即没有参数也没有返回值的函数类型为：() -&gt; ().<br>我们可以把函数类型实例赋给变量：<br>let evenOddFunction:([Int])-([Int],[Int]) = sortedEvenOddNumbers<br>evenOddFunction</p>
<h1 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h1><p>闭包（closure）是在应用中完成特定任务的互相分离的功能组。函数是闭包的特殊情况，可以把函数理解为有名字的闭包。</p>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    (parameters) -&gt; return type in</span><br><span class="line">    &#x2F;&#x2F; code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>关键字in是用来分隔闭包的参数、返回值与闭包体的语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eg 1:</span><br><span class="line">let array &#x3D; [1,2,54,53,9]</span><br><span class="line">func sortAscending(_ i:Int,_ j:Int) -&gt; Bool &#123;</span><br><span class="line">    return i &lt; j</span><br><span class="line">&#125;</span><br><span class="line">let sortedArray &#x3D; array.sorted(by:sortAscending)</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">eg 2:内联闭包</span><br><span class="line">let array &#x3D; [1,2,54,53,9]</span><br><span class="line">let sortedArray &#x3D; array.sorted(by:&#123;</span><br><span class="line">    (i:Int,j:Int) -&gt; Bool in</span><br><span class="line">    return i &lt; j</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eg 3:</span><br><span class="line">let array &#x3D; [1,2,54,53,9]</span><br><span class="line">let sortedArray &#x3D; array.sorted(by:&#123;</span><br><span class="line">    (i,j) in i &lt; j</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果有多个表达式不可省略return<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg 4:</span><br><span class="line">let array &#x3D; [1,2,54,53,9]</span><br><span class="line">let sortedArray &#x3D; array.sorted(by:&#123;$0 &lt; $1&#125;)</span><br></pre></td></tr></table></figure><br>$number,是利用联快捷参数语法，这样就可以不用声明参数了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eg 5:</span><br><span class="line">let array &#x3D; [1,2,54,53,9]</span><br><span class="line">let sortedArray &#x3D; array.sorted&#123;$0 &lt; $1&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="尾部闭包语法"><a href="#尾部闭包语法" class="headerlink" title="尾部闭包语法"></a>尾部闭包语法</h2><p>上面是尾部闭包语法，对于闭包体很长的情况特别有用，如果一个闭包是以一个函数的最后一个参数传递的，那么它就可以在函数的圆括号以外内联，因为sorted(by:)只接受一个参数，所以可以根本不需要圆括号，只所以可以省略闭包的参数名，是因为尾部闭包语法允许这么做。</p>
<h2 id="闭包是引用类型"><a href="#闭包是引用类型" class="headerlink" title="闭包是引用类型"></a>闭包是引用类型</h2><p>这意味着你把函数赋给变量或常量时，实际上是让这个常量或变量指向这个函数。</p>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>funtional programming</p>
<h2 id="一等公民函数"><a href="#一等公民函数" class="headerlink" title="一等公民函数"></a>一等公民函数</h2><p>函数可以作为返回值从别的函数返回，也可以作为参数传递给别的函数，可以存储在变量中，等等，就跟其他类型一样。</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>函数没有副作用，给定同样的输入，函数永远返回同样的输出，而且不会修改程序中其他地方的状态。</p>
<h2 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h2><p>不鼓励可变性，因为值可变的数据更难分析</p>
<h2 id="强类型"><a href="#强类型" class="headerlink" title="强类型"></a>强类型</h2><p>强类型系统能增加代码的允许时安全性</p>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>sorted(by:),map(<em>:),filter(</em>:),reduce(_:_:)<br>高阶函数至少接受一个函数作为输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let curPopulations &#x3D; [1233,3322,4444]</span><br><span class="line">let mayPopulations &#x3D; curPopulations.map&#123;</span><br><span class="line">    (population: Int) -&gt; Int in</span><br><span class="line">    return population * 2</span><br><span class="line">&#125;</span><br><span class="line">let bigPopulations &#x3D; curPopulations.filter &#123;</span><br><span class="line">    (population: Int) -&gt; Int in</span><br><span class="line">    return population &gt; 4000</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let totalPopulation &#x3D; curPopulations.reduce(0) &#123;</span><br><span class="line">    (first: Int,second: Int) -&gt; Int in</span><br><span class="line">    return first + second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>map：可以对数组中的每一个值进行修改。<br>filter:可基于某些条件对数组进行过滤<br>reduce:可以把一组数组中所有值相加</p>
<h1 id="enum-枚举"><a href="#enum-枚举" class="headerlink" title="enum 枚举"></a>enum 枚举</h1><p>在swift中 不需要使用break跳出当前匹配，默认只执行一个case就结束<br>一次匹配多个模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Weather &#123;</span><br><span class="line">    case rain, snow, wind, sunny</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch todayWeather &#123;</span><br><span class="line">case .rain, .snow:</span><br><span class="line">    print(&quot;天气不太好，出门要打伞&quot;)</span><br><span class="line">case .wind:</span><br><span class="line">    print(&quot;刮风&quot;)</span><br><span class="line">case .sunny:</span><br><span class="line">    print(&quot;晴天&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum TextAlignment &#123;</span><br><span class="line">case left</span><br><span class="line">case right</span><br><span class="line">case center </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>var alignment = TextAlignment.left</p>
<p>枚举体至少包含一个case语句。<br>所有的switch语句必须被全覆盖。<br>对枚举类型建议不使用default分支，这样更面向未来</p>
<h2 id="原始值枚举"><a href="#原始值枚举" class="headerlink" title="原始值枚举"></a>原始值枚举</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum TextAlignment: Int &#123;</span><br><span class="line">    case left</span><br><span class="line">    case right</span><br><span class="line">    case center</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Int即为原始值，默认第一个为0，也可以指定值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum TextAlignment: Int &#123;</span><br><span class="line">    case left &#x3D; 10</span><br><span class="line">    case right &#x3D; 20</span><br><span class="line">    case center &#x3D; 30</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;Left has raw value \(TextAlignment.left.rawValue)&quot;)</span><br><span class="line">let rawValue &#x3D; 20</span><br><span class="line">let myAlignment &#x3D; TextAlignment(rawValue:rawValue)</span><br></pre></td></tr></table></figure>
<p>Swift 中对enum除了可以用int做原始值，还可以使用所有的内建值类型和字符串。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Language: String &#123;</span><br><span class="line">    case swift &#x3D; &quot;Swift&quot;</span><br><span class="line">    case c &#x3D; &quot;C&quot;</span><br><span class="line">    case java</span><br><span class="line">    case python</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果是String作为原始值，如果省略了原始值，会使用成员本身的名字作为原始值<br>enum是值类型，值类型的方法不能对self进行修改。如果需要修改需要在函数前加上mutating<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutating fucn tlggle()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关联值"><a href="#关联值" class="headerlink" title="关联值"></a>关联值</h2><p>关联值可以把数据附在枚举实例上，不同成员可以有不同类型的关联值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum ShapeDimensions &#123;</span><br><span class="line">    case oquare(side:Double)</span><br><span class="line">    case rectangle(width:Double,height:Double)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">var squreShape &#x3D; ShapeDimensions.square(side: 10.0)</span><br><span class="line">var rectShape &#x3D; ShapeDimensions.rectangle(width:5.0,height:10.0)</span><br></pre></td></tr></table></figure><br>要创建shapDimension实例，必须指定成员和相应的关联值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum ShapeDimension &#123;</span><br><span class="line">    case square(side: Double)</span><br><span class="line">    case rectangle(width: Double,height: Double)</span><br><span class="line">    </span><br><span class="line">    func area() -&gt; Double &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case let .square(side: side):</span><br><span class="line">            return side * side</span><br><span class="line">        case let .rectangle(width: w, height: d):</span><br><span class="line">            return w * d</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的switch分支利用了swift的模式匹配</p>
<h2 id="递归枚举"><a href="#递归枚举" class="headerlink" title="递归枚举"></a>递归枚举</h2><p>枚举工作原理，Swift编译器必须知道程序中每种类型的每一个实例占据多少内存空间。如果无法知道将要占用多少内存需要使用关键字indirect告诉编译器把枚举数据放到一个指针指向的地方。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">indirect enum FamilyTree &#123;</span><br><span class="line">    case noKnownParents</span><br><span class="line">    case oneKnownParent(name:String, ancestors:FamilyTree)</span><br><span class="line">    case twoKnownParents(fatherName:String,fatherAncestor:FamilyTree,motherName: String,motherAncestor:FamilyTree)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>swift中一个指针是8个字节<br>也可以把成员标记为indirect<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum FamilyTree &#123;</span><br><span class="line">    case noKnownParents</span><br><span class="line">    indirect case oneKnownParent(name:String, ancestors:FamilyTree)</span><br><span class="line">    indirect case twoKnownParents(fatherName:String,fatherAncestor:FamilyTree,motherName: String,motherAncestor:FamilyTree)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><p>swift中的switch功能远比OC强大：</p>
<h2 id="无需break"><a href="#无需break" class="headerlink" title="无需break ,"></a>无需break ,</h2><p>而swift的switch语句是满足其中一个条件后，执行完就会停止.</p>
<h2 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h2><p>状态转移语句：如果某一个匹配上的分支末尾有fallthrough，它会把控制权传递给下一个分支，无论它跟正在检验的值是否匹配。</p>
<h2 id="一个分支多个值，用逗号分开"><a href="#一个分支多个值，用逗号分开" class="headerlink" title="一个分支多个值，用逗号分开"></a>一个分支多个值，用逗号分开</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">switch statusCode &#123;</span><br><span class="line">    case 100,101:</span><br><span class="line">    print(&quot;1&quot;)</span><br><span class="line">    case 300...307:</span><br><span class="line">    print (&quot;2&quot;)</span><br><span class="line">    case let unknownCode:</span><br><span class="line">    print(&quot;unknown&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间"><a href="#区间" class="headerlink" title="区间"></a>区间</h2><p>switch 语句可以使用valueX…valueY这样的语法来把某个区间的内容值与给定值比较。</p>
<h2 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h2><p>值绑定能在某个特定分支中把待匹配的值绑定到本地常量或变量上，这个常量或变量只能在该分支上使用。</p>
<h2 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h2><h2 id="类型匹配"><a href="#类型匹配" class="headerlink" title="类型匹配"></a>类型匹配</h2><p>匹配模式可以应用于类型上，这时我们需要用到两个关键字 is、as （注意：不是as?，尽管它们的机制很相似，但是它们的语义是不同的（“尝试进行类型转换，如果失败就返回 nil” vs “判断这个模式是不是匹配这种类型”））<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">protocol Animal &#123;</span><br><span class="line">    var name: String &#123; get &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Dog: Animal &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        return &quot;dog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var runSpeed: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Bird: Animal &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        return &quot;bird&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var flightHeight: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Fish: Animal &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        return &quot;fish&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    var depth: Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animals &#x3D; [Dog.init(runSpeed: 55), Bird.init(flightHeight: 2000), Fish.init(depth: 100)]</span><br><span class="line"></span><br><span class="line">for animal in animals &#123;</span><br><span class="line">    switch animal &#123;</span><br><span class="line">    case let dog as Dog:</span><br><span class="line">        print(&quot;\(dog.name) can run \(dog.runSpeed)&quot;)</span><br><span class="line">    case let fish as Fish:</span><br><span class="line">        print(&quot;\(fish.name) can dive depth \(fish.depth)&quot;)</span><br><span class="line">    case is Bird:</span><br><span class="line">        print(&quot;bird can fly!&quot;)</span><br><span class="line">    default:</span><br><span class="line">        print(&quot;unknown animal!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="自定义类型匹配"><a href="#自定义类型匹配" class="headerlink" title="自定义类型匹配"></a>自定义类型匹配</h2><p>通常情况下，我们自定的类型是无法进行模式匹配的，也就是不能在 switch/case 语句中使用。如果想要达到可匹配的效果，那么就有必有了解一下匹配操作符 ~=<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct BodyFatRate &#123;</span><br><span class="line">    var weight: Float</span><br><span class="line">    var fat: Float</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let player &#x3D; BodyFatRate(weight: 180, fat: 30)</span><br><span class="line"></span><br><span class="line">func ~&#x3D;(lhs: Range&lt;Float&gt;, rhs: BodyFatRate) -&gt; Bool &#123;</span><br><span class="line">    return lhs.contains(rhs.fat &#x2F; rhs.weight)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch player &#123;</span><br><span class="line">case 0.0..&lt;0.15:</span><br><span class="line">    print(&quot;难以置信&quot;)</span><br><span class="line">case 0.15..&lt;0.2:</span><br><span class="line">    print(&quot;健康&quot;)</span><br><span class="line">case 0.21..&lt;0.99:</span><br><span class="line">    print(&quot;该减肥了&quot;)</span><br><span class="line">default:</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意这里区间是”..&lt;”</p>
<h2 id="Optional-匹配"><a href="#Optional-匹配" class="headerlink" title="Optional 匹配"></a>Optional 匹配</h2><p>当switch传入的值为optional时，如果不想解包，可以使用x?（相当于Optional.some(x)）语法糖来匹配可选值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let optionalValue: Int? &#x3D; 5</span><br><span class="line"></span><br><span class="line">switch optionalValue &#123;</span><br><span class="line">case 1?:</span><br><span class="line">    print(&quot;it&#39;s one&quot;)</span><br><span class="line">case 2?:</span><br><span class="line">    print(&quot;it&#39;s two&quot;)</span><br><span class="line">case .none:</span><br><span class="line">    print(&quot;it&#39;s nil&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;it&#39;s others&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码中，optionalValue相当于 Optional.some(5)，所以也需要同Optional.some(x)进行比较。如果case中的值没有加上 ？则会报错:expression pattern of type ‘Int’ cannot match values of type ‘Int?’。当 optionalValue 为nil时，则与 .none 匹配。在Swift中，Int型被认为是无法穷举的，故必须有default</p>
<h2 id="switch模式匹配"><a href="#switch模式匹配" class="headerlink" title="switch模式匹配"></a>switch模式匹配</h2><p>Swift中的匹配模式要比OC中强大的多。归纳起来大概分为以下几点：<br>除了可以匹配枚举类型外，支持更多的原生类型匹配，包过Int、String、Float、Tuple、Range等<br>可以对类型进行匹配，配合 as、is 来使用<br>重载匹配操作符~=，可以支持自定义类型的匹配操作<br>可结合where、if、guard、for来使用，使得代码简洁优雅而高效<br>对Optional类型的匹配支持很友好，可简化部分判断逻辑</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>当匹配的类型无法穷举时，必须添加 default<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let name &#x3D; &quot;Spiderman&quot;</span><br><span class="line"></span><br><span class="line">switch name &#123;</span><br><span class="line">case &quot;Ironman&quot;:</span><br><span class="line">    print(&quot;钢铁侠&quot;)</span><br><span class="line">case &quot;Spiderman&quot;:</span><br><span class="line">    print(&quot;蜘蛛侠&quot;)</span><br><span class="line">default: &#x2F;&#x2F; 由于无法穷举所有字符串，所以必须添加 default </span><br><span class="line">    print(&quot;不认识&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h3><p>元组匹配类似于枚举关联值的匹配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let point &#x3D; (x: 10, y: 0)</span><br><span class="line"></span><br><span class="line">switch point &#123;</span><br><span class="line">case (0, 0): </span><br><span class="line">    print(&quot;原点&quot;)</span><br><span class="line">case (0, _): &#x2F;&#x2F; 由于不关心 y，所以使用 _ 来进行占位</span><br><span class="line">    print(&quot;Y轴p偏移&quot;)</span><br><span class="line">case (let x, 0):</span><br><span class="line">    print(&quot;X轴偏移：\(x)&quot;)</span><br><span class="line">case (let x, let y) where x &#x3D;&#x3D; y: </span><br><span class="line">    print(&quot;X &#x3D; Y&quot;)</span><br><span class="line">default: </span><br><span class="line">    break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="is-as-as-as"><a href="#is-as-as-as" class="headerlink" title="is as as? as!"></a>is as as? as!</h1><h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><p>is 相当于OC中的isKindOfClass</p>
<h2 id="as"><a href="#as" class="headerlink" title="as"></a>as</h2><p>从派生类转换为基类，向上转型，即可以把子类转换为父类;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Amimal&#123;&#125;</span><br><span class="line">class Cat:Animal&#123;&#125;</span><br><span class="line">let cat &#x3D; Cat()</span><br><span class="line">let animal &#x3D; cat as Animal</span><br></pre></td></tr></table></figure><br>除二义性，数值类型转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let age &#x3D; 28 as Int</span><br><span class="line">let money &#x3D; 20 as CGFloat</span><br><span class="line">let cost &#x3D; (50 &#x2F; 2) as Double</span><br></pre></td></tr></table></figure><br>switch 语句中进行模式匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch person1 &#123;</span><br><span class="line">    case let person1 as Student:</span><br><span class="line">        print(&quot;是Student类型，打印学生成绩单...&quot;)</span><br><span class="line">    case let person1 as Teacher:</span><br><span class="line">        print(&quot;是Teacher类型，打印老师工资单...&quot;)</span><br><span class="line">    default: break</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="as-1"><a href="#as-1" class="headerlink" title="as!"></a>as!</h2><p>向下转型<br>子类可以向上转换为超类，但超类不能向下（downcast）转换为子类。除非某个子类的对象表现形式为超类，但实际是子类，这时可以使用as！进行向下转换（downcast）</p>
<h1 id="stuct"><a href="#stuct" class="headerlink" title="stuct"></a>stuct</h1><p>如果一个结构体的一个实例方法要修改结构体的属性，就必须标记为mutating。结构体和Enum没有继承.<br>对值类型的变量进行传递时总是会被复制。<br>要声明类型方法和属性时需要用到static关键字 。</p>
<h2 id="mutating"><a href="#mutating" class="headerlink" title="mutating"></a>mutating</h2><h1 id="class"><a href="#class" class="headerlink" title="class"></a>class</h1><h2 id="禁止重写"><a href="#禁止重写" class="headerlink" title="禁止重写"></a>禁止重写</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Zombie:Monster &#123;</span><br><span class="line">    final override func terrorizeTown() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以用关键字final让方法或属性不可重写<br>类的类型方法要用class 关键字标记。<br>如果不想让子类覆盖某个类方法可以加上static关键字或者final class 关键字<br>类方法可以调用其他类方法或者类属性<br>swift的实例方法，实际上是返回函数的类级别的方法。</p>
<h2 id="禁止继承"><a href="#禁止继承" class="headerlink" title="禁止继承"></a>禁止继承</h2><p>用final 标记的类可以防止其他人继承</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>惰性存储属性必须为var变量。lazy属性只有在第一次访问时才会计算它的值。<br>存储属性的类属性必须有默认值，因为类型没有初始化方法。</p>
<h2 id="属性观察"><a href="#属性观察" class="headerlink" title="属性观察"></a>属性观察</h2><p>只用于存储属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var population &#x3D; 23 &#123;</span><br><span class="line">    didSet(OldPopulation) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    willSet(newPopulation) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>didSet观察者能让我们问􏵋性的􏶞值。 如果不􏰆定新名字，Swift会自动把􏲺数命名为oldValue,willSet默认名字为newValue<br>但是在初始化函数中不会走到观察属性的didSet和willSet</p>
<h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性不会像存储属性那样存储值，而是提供一个读取方法(get)来获取属性的值，并可选地提供一个写入方法（set）设置属性的值。<br>只读的计算属性是用var定义的。<br>类级别的计算属性的定义跟方法很像，主要区别是用关键字var不是func，以及没有圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Zombie: Monster &#123;</span><br><span class="line">    class var spookyNoise: String &#123;</span><br><span class="line">        return &quot;Brains ... &quot;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面是读取方法的快捷语法，如果计算属性没有写入方法，就可以省略计算属性定义中的get，并直接返回所需的计算值。<br>静态属性和类型属性最大的区别是静态属性无法被子类覆盖。</p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>访问控制主要围绕模块（比如某个framework）和源代码文件。</p>
<h3 id="open"><a href="#open" class="headerlink" title="open"></a>open</h3><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><h3 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h3><p>默认访问层级</p>
<h3 id="fileprivate"><a href="#fileprivate" class="headerlink" title="fileprivate"></a>fileprivate</h3><h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p><img src="/res/images/article/swift/1.png" alt="image"><br>如果属性既有存取方法又有写入方法，可以分别控制它们的可见度，默认情况下，读取方法和写入方法的可见度相同。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Zombie: Monster &#123;</span><br><span class="line">    internal private(set) var isFallingApart &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line">class Zombie: Monster &#123;</span><br><span class="line">    private(set) var isFallingApart &#x3D; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>只要写入方法的可见度不比读取方法更高就可以。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>结构体和类的存储属性在初始化完成的时候需要有初始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct CustomType &#123;</span><br><span class="line">    init (someValue:SomeType) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>用init表示，前面不用有func<br>结构体可以有默认初始化方法:<code>空初始化方法</code>和<code>成员初始化方法</code>（对类型的每个存储属性都有相应的外部参数）<br>如果有自定义初始化方法了，就不会提供默认的初始化方法了。<br>一旦写了自定义初始化方法，Swift就不会提供默认的初始化方法了<br>Swift 允许在初始化过程中初始化常量属性。</p>
<h2 id="委托初始化"><a href="#委托初始化" class="headerlink" title="委托初始化"></a>委托初始化</h2><p>初始化方法的定义中包含对该类型其他初始化方法的调用。为了提供多种创建实例的路径。</p>
<h2 id="（designated-amp-convenience）初始化方法的概念"><a href="#（designated-amp-convenience）初始化方法的概念" class="headerlink" title="（designated &amp; convenience）初始化方法的概念"></a>（designated &amp; convenience）初始化方法的概念</h2><p>指定初始化方法负责确保初始化完成前所有的属性都有值，便捷初始化方法是指定初始化方法的补充，通过调用所在类的指定初始化方法来实现。</p>
<p>类没有默认的成员初始化方法。<br>初始化方法自动继承<br>一般来说，类不会继承父类的初始化方法，Swift的这个特性是希望避免子类在不经意间提供无法为所有属性赋值的初始化方法。以下情况类会继承父类的初始化方法：<br>1.如果子类没有定义任何指定初始化方法。<br>2.如果子类实现了父类的所有指定初始化方法（无论是通过显示实现还是隐私继承），就会继承所有便捷初始化方法。</p>
<h2 id="指定初始化方法"><a href="#指定初始化方法" class="headerlink" title="指定初始化方法"></a>指定初始化方法</h2><p>类的主要初始化方法就是指定初始化方法，指定初始化方法的一部分作用是确保类的所有属性在初始化完成前都有值。<br><strong>如果类有父类，那么子类的指定初始化方法必须调用父类的指定初始化方法。</strong><br>如果在调用指定初始化之前访问了属性的值会报这个错误：Use of ‘self’ in delegating initializer before self.init is called<br>在便捷初始化函数中无法给let型常量赋值</p>
<h2 id="便捷初始化方法"><a href="#便捷初始化方法" class="headerlink" title="便捷初始化方法"></a>便捷初始化方法</h2><p>用关键字 convenience修饰。<br>便捷初始化必须调用到其所在类的其他初始化方法。</p>
<h2 id="必须初始化方法"><a href="#必须初始化方法" class="headerlink" title="必须初始化方法"></a>必须初始化方法</h2><p>类可以要求其子类提供特定的初始化方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">required init (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反初始化"><a href="#反初始化" class="headerlink" title="反初始化"></a>反初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deinit &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>deinit方法可以访问实例的所有属性和方法<br>Swift中只有可空类型可以是nil</p>
<h2 id="可失败的初始化方法"><a href="#可失败的初始化方法" class="headerlink" title="可失败的初始化方法"></a>可失败的初始化方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">init?(...) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h1><p>值类型内使用引用类型时要务必小心，在引用类型内使用值类型倒不会有什么问题<br>建议不要在值类型内使用引用类型。如果确实需要在值类型中使用引用类型属性，最好使用不可变实例。</p>
<p>swift没有提供可以执行深复制的方法，如果需要，必须自己编写</p>
<h2 id="相等和同一"><a href="#相等和同一" class="headerlink" title="相等和同一"></a>相等和同一</h2><p>相等是指两个实例就可见的特性来说具有一样的值。比如同样文本的两个String实例。<br>同一是指两个变量或常量是否指向内存中的同一个实例。</p>
<h1 id="stuct-与-class"><a href="#stuct-与-class" class="headerlink" title="stuct 与 class"></a>stuct 与 class</h1><p>1.如果类型需要传值，用struct。<br>2.如果类型不支持子类继承，用struct。<br>3.如果类型要表达的行为相对比较直观，而且包含一些简单值，那么考虑优先使用struct。<br>4.其他情况都用class</p>
<h1 id="inlinable"><a href="#inlinable" class="headerlink" title="@inlinable"></a>@inlinable</h1><h1 id="frozen"><a href="#frozen" class="headerlink" title="@frozen"></a>@frozen</h1>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/iOS/" rel="tag"># iOS</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/07/20/JavaEE/" rel="prev" title="JavaEE 简介">
      <i class="fa fa-chevron-left"></i> JavaEE 简介
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#函数"><span class="nav-number">1.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变长参数"><span class="nav-number">1.1.</span> <span class="nav-text">变长参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认参数值"><span class="nav-number">1.2.</span> <span class="nav-text">默认参数值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#in-out-参数"><span class="nav-number">1.3.</span> <span class="nav-text">in-out 参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#闭包："><span class="nav-number">2.</span> <span class="nav-text">闭包：</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#尾部闭包语法"><span class="nav-number">2.1.</span> <span class="nav-text">尾部闭包语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包是引用类型"><span class="nav-number">2.2.</span> <span class="nav-text">闭包是引用类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数式编程"><span class="nav-number">3.</span> <span class="nav-text">函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一等公民函数"><span class="nav-number">3.1.</span> <span class="nav-text">一等公民函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#纯函数"><span class="nav-number">3.2.</span> <span class="nav-text">纯函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变性"><span class="nav-number">3.3.</span> <span class="nav-text">不可变性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强类型"><span class="nav-number">3.4.</span> <span class="nav-text">强类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数"><span class="nav-number">3.5.</span> <span class="nav-text">高阶函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#enum-枚举"><span class="nav-number">4.</span> <span class="nav-text">enum 枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#原始值枚举"><span class="nav-number">4.1.</span> <span class="nav-text">原始值枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关联值"><span class="nav-number">4.2.</span> <span class="nav-text">关联值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#递归枚举"><span class="nav-number">4.3.</span> <span class="nav-text">递归枚举</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#switch"><span class="nav-number">5.</span> <span class="nav-text">switch</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#无需break"><span class="nav-number">5.1.</span> <span class="nav-text">无需break ,</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fallthrough"><span class="nav-number">5.2.</span> <span class="nav-text">fallthrough</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个分支多个值，用逗号分开"><span class="nav-number">5.3.</span> <span class="nav-text">一个分支多个值，用逗号分开</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#区间"><span class="nav-number">5.4.</span> <span class="nav-text">区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#值绑定"><span class="nav-number">5.5.</span> <span class="nav-text">值绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where子句"><span class="nav-number">5.6.</span> <span class="nav-text">where子句</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型匹配"><span class="nav-number">5.7.</span> <span class="nav-text">类型匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义类型匹配"><span class="nav-number">5.8.</span> <span class="nav-text">自定义类型匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional-匹配"><span class="nav-number">5.9.</span> <span class="nav-text">Optional 匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch模式匹配"><span class="nav-number">5.10.</span> <span class="nav-text">switch模式匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">5.10.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tuple"><span class="nav-number">5.10.2.</span> <span class="nav-text">Tuple</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#is-as-as-as"><span class="nav-number">6.</span> <span class="nav-text">is as as? as!</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#is"><span class="nav-number">6.1.</span> <span class="nav-text">is</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#as"><span class="nav-number">6.2.</span> <span class="nav-text">as</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#as-1"><span class="nav-number">6.3.</span> <span class="nav-text">as!</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stuct"><span class="nav-number">7.</span> <span class="nav-text">stuct</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mutating"><span class="nav-number">7.1.</span> <span class="nav-text">mutating</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#class"><span class="nav-number">8.</span> <span class="nav-text">class</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#禁止重写"><span class="nav-number">8.1.</span> <span class="nav-text">禁止重写</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#禁止继承"><span class="nav-number">8.2.</span> <span class="nav-text">禁止继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#属性"><span class="nav-number">9.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#存储属性"><span class="nav-number">9.1.</span> <span class="nav-text">存储属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性观察"><span class="nav-number">9.2.</span> <span class="nav-text">属性观察</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算属性"><span class="nav-number">9.3.</span> <span class="nav-text">计算属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#访问控制"><span class="nav-number">9.4.</span> <span class="nav-text">访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#open"><span class="nav-number">9.4.1.</span> <span class="nav-text">open</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public"><span class="nav-number">9.4.2.</span> <span class="nav-text">public</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#internal"><span class="nav-number">9.4.3.</span> <span class="nav-text">internal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fileprivate"><span class="nav-number">9.4.4.</span> <span class="nav-text">fileprivate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#private"><span class="nav-number">9.4.5.</span> <span class="nav-text">private</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初始化"><span class="nav-number">10.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#委托初始化"><span class="nav-number">10.1.</span> <span class="nav-text">委托初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#（designated-amp-convenience）初始化方法的概念"><span class="nav-number">10.2.</span> <span class="nav-text">（designated &amp; convenience）初始化方法的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指定初始化方法"><span class="nav-number">10.3.</span> <span class="nav-text">指定初始化方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#便捷初始化方法"><span class="nav-number">10.4.</span> <span class="nav-text">便捷初始化方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#必须初始化方法"><span class="nav-number">10.5.</span> <span class="nav-text">必须初始化方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反初始化"><span class="nav-number">10.6.</span> <span class="nav-text">反初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可失败的初始化方法"><span class="nav-number">10.7.</span> <span class="nav-text">可失败的初始化方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#值类型和引用类型"><span class="nav-number">11.</span> <span class="nav-text">值类型和引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相等和同一"><span class="nav-number">11.1.</span> <span class="nav-text">相等和同一</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#stuct-与-class"><span class="nav-number">12.</span> <span class="nav-text">stuct 与 class</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#inlinable"><span class="nav-number">13.</span> <span class="nav-text">@inlinable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#frozen"><span class="nav-number">14.</span> <span class="nav-text">@frozen</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Light"
      src="/images/avatar/lightning.png">
  <p class="site-author-name" itemprop="name">Light</p>
  <div class="site-description" itemprop="description">Keep going……</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:heliangzhang@yeah.net" title="E-Mail → mailto:heliangzhang@yeah.net" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Light</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: ,
      el: 'wpac-rating',
      color: 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.css">
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
